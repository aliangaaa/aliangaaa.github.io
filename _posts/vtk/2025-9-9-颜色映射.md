---
layout: post
title: 颜色映射
category: vtk
tags: Essay
keywords: 
description: 
---

### 对于目标不想显示的灰度值/标量值可以设置颜色映射的透明度为0，使它“消失”

### vtkLookupTable 会自动线性映射
```
  // 创建 LookupTable
  auto lut = vtkSmartPointer<vtkLookupTable>::New();
  lut->SetNumberOfTableValues(3);
  lut->Build();
  lut->setRange(humin, humax);
  lut->SetTableValue(0, 1.0, 0.0, 0.0);
  lut->SetTableValue(1, 0.0, 1.0, 0.0);
  lut->SetTableValue(2, 0.0, 0.0, 1.0);
```
build--我理解类似于update，把颜色设置到lut的内部结构中
modifyed--通知相连的管线更新
对于这个颜色映射如果标量数小于lut颜色数，可能会不线性映射，直接一一对应。有点奇怪，也可能需要将mapper（SetScalarRange）设置范围？

### vtkColorTransferFunction 一一对应的颜色映射
在polydata中使用
```
  auto sphere = vtkSmartPointer<vtkSphereSource>::New();
  sphere->SetThetaResolution(30);
  sphere->SetPhiResolution(30);
  sphere->Update();
  
  auto polydata = sphere->GetOutput();
  
  // 给每个点设置标量值 (这里用 Z 坐标作为标量)
  auto scalars = vtkSmartPointer<vtkFloatArray>::New();
  for(vtkIdType i = 0; i < polydata->GetNumberOfPoints(); i++)
  {
      double p[3];
      polydata->GetPoint(i, p);
      scalars->InsertNextValue(p[2]); // Z坐标
  }
  polydata->GetPointData()->SetScalars(scalars);
  
  // 创建颜色映射函数
  auto ctf = vtkSmartPointer<vtkColorTransferFunction>::New();
  ctf->AddRGBPoint(-1.0, 0.0, 0.0, 1.0); // 蓝色
  ctf->AddRGBPoint(0.0, 0.0, 1.0, 0.0);  // 绿色
  ctf->AddRGBPoint(1.0, 1.0, 0.0, 0.0);  // 红色
  
  // 创建 Mapper
  auto mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
  mapper->SetInputData(polydata);
  mapper->SetLookupTable(ctf);
  mapper->SetColorModeToMapScalars();
  mapper->SetScalarRange(polydata->GetScalarRange());
  
  // 创建 Actor
  auto actor = vtkSmartPointer<vtkActor>::New();
  actor->SetMapper(mapper);
  
  // 创建 Renderer 和 RenderWindow
  auto renderer = vtkSmartPointer<vtkRenderer>::New();
  renderer->AddActor(actor);
  renderer->SetBackground(0.1, 0.1, 0.1);
```
在volume中使用
```
// 创建颜色传递函数
    auto colorFunc = vtkSmartPointer<vtkColorTransferFunction>::New();
    colorFunc->AddRGBPoint(0, 0.0, 0.0, 0.0);      // 黑
    colorFunc->AddRGBPoint(128, 1.0, 0.0, 0.0);    // 红
    colorFunc->AddRGBPoint(255, 1.0, 1.0, 1.0);    // 白

    // 创建不透明度传递函数
    auto opacityFunc = vtkSmartPointer<vtkPiecewiseFunction>::New();
    opacityFunc->AddPoint(0, 0.0);
    opacityFunc->AddPoint(128, 0.2);
    opacityFunc->AddPoint(255, 0.8);

    // 设置体属性
    auto volumeProperty = vtkSmartPointer<vtkVolumeProperty>::New();
    volumeProperty->SetColor(colorFunc);
    volumeProperty->SetScalarOpacity(opacityFunc);
    volumeProperty->ShadeOn();
    volumeProperty->SetInterpolationTypeToLinear();

    // 创建 GPU Volume Mapper  或者使用通用的vtkSmartVolumeMapper
    auto volumeMapper = vtkSmartPointer<vtkGPUVolumeRayCastMapper>::New();
    volumeMapper->SetInputData(imageData);

    // 创建体 Actor
    auto volume = vtkSmartPointer<vtkVolume>::New();
    volume->SetMapper(volumeMapper);
    volume->SetProperty(volumeProperty);

    // Renderer
    auto renderer = vtkSmartPointer<vtkRenderer>::New();
    renderer->AddVolume(volume);
    renderer->SetBackground(0.1, 0.1, 0.1);
```
### 注意在做等值面提取时， 提取到的标量值是第二个参数，第一个参数等值面索引
```
  auto contourFilter = vtkSmartPointer<vtkContourFilter>::New();
  contourFilter->SetInputData(imageData);
  contourFilter->SetValue(0, threshold);
  contourFilter->Update();
  auto polydata = contourFilter->GetOutput();
  auto scalars = polydata->GetPointData()->GetScalars();
  
  if (!scalars) {
      std::cout << "No scalars found!" << std::endl;
  } else {
      std::cout << "Number of points: " << polydata->GetNumberOfPoints() << std::endl;
      for (vtkIdType j = 0; j < polydata->GetNumberOfPoints(); ++j) {
          double val = scalars->GetTuple1(j);
          std::cout << "Point " << j << " scalar: " << val << std::endl;
      }
  }
```
#### 使用 vtkImageMapToColors 这个以后，像素值是0-255范围
